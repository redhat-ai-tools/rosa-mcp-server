# Implementation Strategy Q&A

## Question 1: OCM SDK vs Direct HTTP Client

The requirements mention using the `github.com/openshift-online/ocm-sdk-go` for OCM API client integration, while the reference OCM MCP server uses direct HTTP calls with `httpx`. 

**Question:** Should we prioritize using the OCM SDK for authentication and API calls (following the requirements), or would you prefer a lighter approach with direct HTTP calls (like the Python reference implementation)? The OCM SDK provides robust OAuth handling and request/response management but adds complexity.

**My recommendation:** Use the OCM SDK as specified in requirements since it handles OAuth refresh tokens automatically and provides type-safe API interactions, which is more maintainable for a Go implementation.

**Answer:** Use the OCM SDK as specified in requirements.

---

## Question 2: Go Module Initialization Strategy

Looking at the current directory structure, I don't see an existing `go.mod` file in the root directory, but there's a reference OpenShift MCP server implementation available.

**Question:** Should we:
1. Initialize a new Go module from scratch in the current directory
2. Create the ROSA HCP MCP server as a subdirectory with its own module
3. Fork/copy the structure from the reference OpenShift MCP server and adapt it

**My recommendation:** Initialize a new Go module in the current directory following the file structure outlined in requirements, but borrowing architectural patterns from the OpenShift MCP reference implementation.

**Answer:** Initialize all new. Consider the OpenShift MCP server **REFERENCE MATERIAL ONLY**. Do not modify it or fork from it.

---

## Question 3: ROSA HCP Cluster Creation Complexity

The requirements specify a `create_rosa_hcp_cluster` tool with 8 required parameters (cluster_name, aws_account_id, billing_account_id, role_arn, operator_role_prefix, oidc_config_id, subnet_ids, region). This suggests complex AWS resource prerequisites.

**Question:** For the MVP implementation, should we:
1. Implement full parameter validation and AWS resource verification before making OCM API calls
2. Pass parameters directly to OCM API and let it handle validation (fail fast approach)
3. Include some basic validation (e.g., ARN format, subnet ID format) but rely on OCM for deeper validation

**My recommendation:** Option 2 - Pass parameters directly to OCM API for MVP. The requirements state "OCM API handles all parameter validation for cluster creation" and "No pre-validation of AWS resources before API calls" is listed in future considerations.

**Answer:** 2. Validation is a future consideration, keep the implementation simple and do not do any validation of parameters.

---

## Question 4: Response Formatting Strategy

The requirements emphasize "Human-readable formatted strings (not JSON)" with "dedicated formatter functions like `formatClustersResponse()`". Looking at the reference implementations:

- OCM MCP (Python) returns JSON responses directly from API
- OpenShift MCP (Go) has structured output formatting

**Question:** For response formatting, should we:
1. Create simple string templates with key information (cluster name, state, API URL, etc.)
2. Implement table-like formatting similar to kubectl output
3. Create detailed multi-line descriptive text for each response

**My recommendation:** Option 1 - Simple string templates that are easy to read but concise. This balances human readability with AI assistant consumption while keeping implementation straightforward.

**Answer:** 1. It is the simplest and ensures we can also replace it with a more complex solution in the future.

---

## Question 5: Testing Strategy for MVP

The requirements mention "Unit testing sufficient for MVP (integration tests future enhancement)" and reference both implementations have different testing approaches.

**Question:** For the MVP testing scope, should we:
1. Focus only on testing formatter functions and basic tool registration
2. Include tests for OCM client wrapper functions with mocked API responses
3. Test end-to-end tool execution with mock OCM SDK clients
4. Minimal testing - just ensure the server starts and tools are registered

**My recommendation:** Option 2 - Test the OCM client wrapper functions with mocked API responses. This ensures our core business logic works without requiring real OCM API access, while keeping the scope manageable for MVP.

**Answer:** 4 just minimal testing. We want to keep it simple. We're using the ocm-sdk-go SDK, which is well tested and validated, so we can rely a bit on it to gain confidence in the OCM API integration.

---